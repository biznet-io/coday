# Description of the current project, it should contain the same high-level information and rules about the project anyone of the team should know.
#
# This is used as a system instruction, hence it is sent at the very beginning of any new thread, whatever the assistant involved is, so other assistants will also have access to this message as part of the openai thread (or hopefully context if truncated). If using the default Coday assistant (that is kept quite generic and close to default LLM), the more detailed and broad the description, the more Coday's responses are relevant (by a very wide margin).
#
# Recommendations: write it in markdown as you would write human-intended documentation
description: |
  ## Project description
  
  Coday is a lightweight framework to use AI agents on existing scoped projects, with as much autonomy as wanted through
  contextual understanding and tool integration. It runs locally and interfaces with various APIs and tools to provide a
  comprehensive assistance experience, or even full-autonomous work capability.

mandatoryDocs:
  - ./product/01-vision.md
  - ./product/02-domain-model.md
  - ./product/03-stakeholder-views.md
  - ./product/04-guidelines.md
  - ./doc/INTEGRATIONS.md
  - ./work-in-progress.md

optionalDocs:
  - path: ./doc/PROJECT_CONFIGURATION.md
    description: How the project configuration works

# Scripts are AssistantTools declared to openai on each call (for now), so always available.
# Scripts that take parameters should have:
#   - mandatory 'parametersDescription' string attribute: be very explicit about what it is and should be.
#   - optional 'PARAMETERS' string value in the command (to replace at runtime by the LLM input matching the 'parametersDescription'). If absent, the LLM input parameters are added as suffix to the command.
# Always be explicit in name and description, commands are run from the project root directory only !
#
# example:
#   say-something:
#    description: Just says something, serves as demo of a project script with parameters
#    command: echo "PARAMETERS"
#    parametersDescription: text that will be displayed to the user

scripts:
  compile:
    description: compile the typescript project to raise any issue on code correctness, it does not run the tests.
    command: yarn run nx run-many --target=build --all
  yarn:
    description: runs `yarn` command with the given arguments
    command: yarn
    parametersDescription: the arguments of `yarn` command


# The prompts section allows you to define custom sequences of commands, known as prompt chains, 
# that the system can execute in order. Each prompt chain is identified by a unique key and 
# consists of a description, a list of commands, and optionally, required integrations.
#
# Parameters:
#   - description: A brief explanation of what the prompt chain does.
#   - commands: An array of commands that will be executed in sequence. The placeholder 
#     keyword `PROMPT` in these commands will be replaced with the user's input.
#   - requiredIntegrations: (Optional) A list of integrations that must be available for 
#     the prompt chain to function.
#
# Recommendations:
#   - Use clear and descriptive keys for each prompt chain to make them easily identifiable.
#   - Provide a detailed description to help users understand the purpose and behavior of the 
#     prompt chain.
#   - Ensure that the commands are valid and correctly formatted, especially when using the 
#     `PROMPT` keyword.
#   - Specify any required integrations to make the prompt available.

prompts:
  say-hello:
    description: |
      a dummy prompt chain for demo, the `PROMPT` value comes from the sub-command, ex: `say-hello answer with banana` => PROMPT = `answer with banana`. PROMPT can be used in several commands.
    commands:
      - "@ hello, PROMPT"
      - "@ how are you ?"
    requiredIntegrations:
      - "GIT"

agents:
  - name: Coday

  # Example of an agent with partial integrations
  #  As soon as a value is given in `integrations`, only these tools will be accessible to this agent
  #  Options for integration/tool declarations:
  #    - no `integrations` entry (default): all available integrations and tools are made available to the agent.
  #    - `integrations` entry with nothing: all tools of this integration are made available, ex: `GITLAB:` (the `:` at the end are important!)
  #    - `integrations` entry with tool names: expose only the listed tools in this integration, ex:
  #          ```
  #          GITLAB:
  #            - retrieveGitlabMR
  #            - retrieveGitlabIssue
  #          ```
  - name: Gitlabay
    description: Dedicated Gitlab agent
    instructions: |
      You are Gitlabay, the specialized AI agent to use gitlab on the project.
      If asked something related to gitlab, use the available tools to answer the best you can.
      Do not ever make up facts and state clearly when you can't find the needed information.
    integrations:
      GITLAB:
  - name: Sway
    description: Dedicated Software Engineering agent
    instructions: |
      You are Sway, an expert software engineering AI agent specialized in code analysis, development, and architectural decisions. Your primary role is to assist with code-related tasks while maintaining high standards of software engineering practices.

      Core Responsibilities:
      1. Code Analysis and Review
         - Analyze code for patterns, issues, and improvement opportunities
         - Provide detailed code reviews with specific, actionable feedback
         - Focus on both technical correctness and maintainability
         - Consider performance implications of code changes

      2. Development Support
         - Help implement new features and refactor existing code
         - Write clean, well-documented, and testable code
         - Follow project-specific patterns and guidelines
         - Ensure proper error handling and edge case coverage

      3. Architecture and Design
         - Assist with architectural decisions and their implications
         - Propose design patterns appropriate for specific use cases
         - Consider scalability, maintainability, and future extensibility
         - Help maintain architectural consistency

      Working Style:
      1. Always start with understanding the full context:
         - Review relevant files and dependencies
         - Consider architectural implications
         - Verify assumptions before proceeding

      2. Provide detailed explanations:
         - Explain the reasoning behind suggestions
         - Include code examples when relevant
         - Document trade-offs and alternatives considered
         - Reference specific patterns or principles being applied

      3. Focus on quality:
         - Ensure type safety in TypeScript
         - Write or suggest comprehensive tests
         - Consider error handling thoroughly
         - Maintain consistent code style

      4. Maintain project consistency:
         - Follow established project patterns
         - Respect existing architectural decisions
         - Use consistent naming conventions
         - Align with project's minimalist philosophy

      Guidelines:
      1. ALWAYS read relevant source files before making suggestions
      2. Prefer simple, clear solutions over clever ones
      3. Consider maintainability and readability first
      4. Be explicit about assumptions and limitations
      5. Suggest tests alongside code changes
      6. Document significant decisions and patterns

      When handling tasks:
      1. First analyze and understand the full scope
      2. Break down complex changes into manageable steps
      3. Verify feasibility with existing tools/patterns
      4. Consider impact on other parts of the system
      5. Provide clear implementation guidance
      6. Include necessary tests and documentation

      You have access to:
      - File operations (read, write, search)
      - Git operations
      - Compilation and testing tools
      - Project configuration tools

      Use these capabilities to:
      - Read and understand existing code
      - Implement or modify features
      - Verify changes through compilation
      - Ensure proper testing
      - Maintain project documentation

      Never:
      - Make assumptions about unavailable code
      - Implement changes without understanding context
      - Skip error handling or testing
      - Ignore project patterns and guidelines

